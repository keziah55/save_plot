""" SavePlot

Module to save/show matplotlib plots (SavePlot) or to save a legend as a
pdf (save_legend).

Checks if given file name already exists. If it does, you will be prompted 
either to overwrite it or enter new name.
"""

import os.path
import sys
from abc import abstractmethod
import numpy as np
import matplotlib.pyplot
from matplotlib.backends.backend_pdf import PdfPages
import getpass


class SavePlt:
    
    def __init__(self, savefile=None, auto_overwrite=False, mode='normal'):
        """ Save a matplotlib figure as a pdf.
        
            Parameters
            ----------
            * savefile : string
                path to write pdf to
            
            * auto_overwrite : bool
                if file exists, overwrite without prompting.
                Note that if 'quiet' mode was selected, auto_overwrite will be
                True. Otherwise, defaults to False.
                
            * mode : {'normal', 'quiet'}
                If quiet, suppress all messages to terminal. This will also
                automatically set auto_overwrite to True in plot().

        """
        # initialise PdfPages object
        self.pdf = None
        # keep save name, so can check if it already exists
        self.savefile = savefile
        self.auto_overwrite = auto_overwrite
        self.mode = mode
        self.saveformat = 'pdf'
        
        if self.mode == 'quiet':
            self.auto_overwrite = True
            
    @abstractmethod
    def plot(self): pass
            
    def set_savefile(self, savefile):
        """ Set savefile """
        self.savefile = savefile
        self._make_pdf_object(savefile)

    def _make_pdf_object(self, file):
        # make PdfPages object
        self.pdf = PdfPages(file)
        # set pdf metadata
        self._set_metadata()

        
    def _message(self, text):
        if self.mode == 'normal':
            print(text)
            
    def _set_metadata(self):
        # get path of file that has called SavePlot
        file = sys.argv[0]
        file = os.path.realpath(file)
        
        # make metadata dict in accordance with the PDF 'Document Information
        # Dicitonary' spec (14.3.3 of PDF v1.7, as v2.0 is not available)
        metadata = self.pdf.infodict()
        metadata['Author'] = getpass.getuser()
        metadata['Subject'] = 'Figure generated by {}'.format(file)
        
    
    @staticmethod
    def path_exists(savefile):
        """ Check if a path exists. If it does, prompt to change/overwrite.
        
            Returns a path.
        """
        
        while os.path.exists(savefile):
            print('{} already exists. Would you like to overwrite it? '
                  '[Y/n]'.format(savefile))
            ow = input()
            if ow.lower() == 'n':
                # get head of path so that user does not have to type full path
                # TODO change this so that the path can be changed by user
                head, _ = os.path.split(savefile)
                print('Please enter new file name:')
                if head: # if not cwd, add '/' to head
                    name = input(head+os.path.sep)
                else:
                    name = input()
                savefile = os.path.join(head, name)
            elif ow.lower() == 'y' or not ow:
                break
            elif ow.lower() != 'y':
                raise Exception('Invalid input. Aborting.')
    
        return savefile
            
    
class SavePlot(SavePlt):
    
    def __init__(self, save=False, savefile=None, auto_overwrite=False,
                 mode='normal'):
        """ Create SavePlot object.
        
            Parameters
            ----------
            * save : bool 
                If True, save the pdf. Otherwise show the plot.
                
            * savefile : string, optional
                File to which the plot should be saved.
                
            * auto_overwrite : bool
                if file exists, overwrite without prompting.
                Note that if 'quiet' mode was selected, auto_overwrite will be
                True. Otherwise, defaults to False.
                
            * mode : {'normal', 'quiet'}
                If quiet, suppress all messages to terminal. This will also
                automatically set auto_overwrite to True in plot().
        """
        
        super().__init__(savefile, auto_overwrite, mode)
        self.save = save
        
    def plot(self, plt):
        """ Show a matplotlib plot or save it as a pdf, then close the object.
            
            Parameters
            ----------
            * plt : matplotlib.pyplot object
                The object to plot
        """

        if self.save and self.savefile is None:
            self._message('Please give valid savefile')
            sys.exit(1)
        
        if self.save:
            if not self.auto_overwrite:
                try:
                    self.savefile = self.path_exists(self.savefile)
                except:
                    sys.exit(1)
                    
            self._make_pdf_object(self.savefile)

            plt.savefig(self.pdf, format=self.saveformat, bbox_inches='tight')
            self.pdf.close()
            self._message('Saved {}'.format(self.savefile))
        else:
            plt.show()
            
        plt.close()
        
        
class SaveLegend(SavePlt):
        
    def plot(self, labels, colours=None, linestyles=None, markers=None,
             figsize=None, **kwargs):
        """ Save a matplotlib legend as a pdf (without a plot).
        
            Parameters
            ----------
            * savefile : string
                path to write legend.pdf to
                
            * labels : list
                list of labels
                
            * colours : list
                list of colours. If None, black will be used for all.
            
            * linestyles : list
                list of linestyles. If None, and markers is None, solid line 
                will be used for all.
                
            * markers : list
                list of markers. If None, will be ignored.
                
            * figsize : tuple
                tuple of width and height (inches) of output figure. 
                If None, will be set to rc.figure.figsize.
            
            * kwargs :
                matplotlib.pyplot.figlegend keyword arguments
                `loc` is set to 'center', but other kwargs, such as `ncol` are
                available
        """

        # create a figure for the data
        fig = matplotlib.pyplot.figure()
        ax = matplotlib.pyplot.gca()
        
        if colours is None and linestyles is None:
            raise RuntimeError('Please provide a list of colours and/or linestyles.')
                
        # if colours/linestyles not provided, use black/solid line for all
        if colours is None:
            colours = ['black'] * len(labels)
        if linestyles is None:
            linestyles = ['-'] * len(labels)
        if markers is None:
            markers = [None] * len(labels)
            
        x = np.arange(10)
        
        for i in range(len(colours)):
            matplotlib.pyplot.plot(x, x * (i+1), colours[i], label=labels[i], 
                                   linestyle=linestyles[i], marker=markers[i])
        
        # create a second figure for the legend
        figLegend = matplotlib.pyplot.figure(figsize=figsize)
        
        # produce a legend for the objects in the other figure
        # loc is a required argument, but makes no difference when only the 
        # legend is being displayed
        matplotlib.pyplot.figlegend(*ax.get_legend_handles_labels(), 
                                    loc='center', **kwargs)

        if not self.auto_overwrite:
            try:
                self.savefile = self.path_exists(self.savefile)
            except:
                sys.exit(1)

        self._make_pdf_object(self.savefile)
        figLegend.savefig(self.pdf, format=self.saveformat, 
                          bbox_inches='tight')
        self.pdf.close()
        
        self._message('Saved {}'.format(self.savefile))
        
        matplotlib.pyplot.close(fig)
        matplotlib.pyplot.close(figLegend)
    
